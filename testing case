import streamlit as st
import pandas as pd
import numpy as np
import snowflake.connector
from scipy.optimize import curve_fit

# --- Setup Streamlit Page ---
st.set_page_config(layout="wide")
st.title("Bond Curve Analyzer - Nelson-Siegel")

# --- Deviation Threshold ---
deviation_threshold = st.slider("Deviation Threshold (%)", 1, 20, 5)

# --- Snowflake Connection ---
@st.cache_resource(show_spinner="Connecting to Snowflake...")
def get_snowflake_connection():
    conn = snowflake.connector.connect(
        user='SAGESNOW',
        password='V2^cHfBnQQdbx28duWx*d',
        account='ESA97740.east-us-2.azure',
        warehouse='COMPUTE_WH',
        database='SAGENEXTGEN',
        schema='PUBLIC'
    )
    return conn

conn = get_snowflake_connection()
cursor = conn.cursor()

# --- Fetch Bloomberg Data ---
@st.cache_data(show_spinner="Fetching Bloomberg bond data...")
def fetch_bloomberg_data(cursor):
    query = "SELECT * FROM TRADERS.BLOOMBERG_IMPORTS.DAILY_CURVE_IG_DATA"
    cursor.execute(query)
    df = cursor.fetch_pandas_all()
    return df

df_bonds = fetch_bloomberg_data(cursor)

# --- Process Bloomberg Data ---
df_bonds['TICKER'] = df_bonds['TICKER'].astype(str)
df_bonds['COUPON'] = df_bonds['COUPON'].astype(str)
df_bonds['MATURDATE'] = pd.to_datetime(df_bonds['MATURDATE'], format='%Y%m%d').dt.strftime('%m/%d/%Y')
df_bonds.insert(3, 'ID', df_bonds['TICKER'] + ' ' + df_bonds['COUPON'] + ' ' + df_bonds['MATURDATE'])

df_bonds['DURADJMOD'] = pd.to_numeric(df_bonds['DURADJMOD'], errors='coerce')
df_bonds['OAS_BP'] = pd.to_numeric(df_bonds['OAS_BP'], errors='coerce')
df_bonds = df_bonds.dropna(subset=['DURADJMOD', 'OAS_BP'])

# Remove low-frequency tickers
df_bonds = df_bonds[df_bonds['TICKER'].map(df_bonds['TICKER'].value_counts()) >= 5]

# --- Fetch Positions Data ---
@st.cache_data(show_spinner="Fetching Position Data...")
def fetch_positions(cursor):
    query = """
        SELECT fm.entity_id, fm.effective_date, trim(sd.ticker) as TICK, left(sd.SECURITY_ID, 8) as CUSIP, sd.*, pd.*
        FROM EAGLE.datamartdbo_fund_summary fs
        INNER JOIN EAGLE.datamartdbo_fund_master fm ON fm.dmart_fund_id = fs.dmart_fund_id
        INNER JOIN EAGLE.datamartdbo_position_details pd ON pd.dmart_fund_id = fs.dmart_fund_id
        INNER JOIN EAGLE.rulesdbo_entity e ON e.entity_ID = fm.entity_ID
        INNER JOIN EAGLE.datamartdbo_security_details sd ON sd.security_alias = pd.security_alias AND sd.effective_date = fm.effective_date
        WHERE sd.security_type = 'Corporate'
        AND e.entity_type = 'PORT'
        AND fm.effective_date = DATEADD(day, -1, CURRENT_DATE())
    """
    cursor.execute(query)
    rows = cursor.fetchall()
    columns = [desc[0] for desc in cursor.description]
    df = pd.DataFrame(rows, columns=columns)
    return df

df_positions = fetch_positions(cursor)

# --- Process Positions ---
df_positions.columns = [f"{col}_{i}" if df_positions.columns.duplicated()[i] else col for i, col in enumerate(df_positions.columns)]
df_positions = df_positions.groupby(['CUSIP', 'TICK'])['SHARE_PAR_VALUE'].sum().reset_index()
df_positions['SHARE_PAR_VALUE'] = pd.to_numeric(df_positions['SHARE_PAR_VALUE'], errors='coerce')
df_positions = df_positions[df_positions['SHARE_PAR_VALUE'] > 3000000]

# --- Merge Ownership Info ---
df_bonds = df_bonds.merge(df_positions[['CUSIP']], on='CUSIP', how='left', indicator=True)
df_bonds['Own?'] = df_bonds['_merge'].map({'both': 'Y', 'left_only': 'N', 'right_only': 'N'})

st.success(f"Fetched {len(df_bonds)} bonds and {len(df_positions)} positions.")

import plotly.graph_objects as go

# --- Nelson-Siegel function ---
def ns_func(x, beta0, beta1, beta2, lambda1):
    term1 = beta0
    term2 = beta1 * (1 - np.exp(-x / lambda1)) / (x / lambda1)
    term3 = beta2 * ((1 - np.exp(-x / lambda1)) / (x / lambda1) - np.exp(-x / lambda1))
    return term1 + term2 + term3

# --- Fit NS curve ---
def fit_ns_curve(x, y):
    try:
        initial_params = [0.01, -0.01, 0.01, 1.0]
        params, _ = curve_fit(ns_func, x, y, p0=initial_params, maxfev=5000)
        y_fit = ns_func(x, *params)
        return params, y_fit
    except Exception as e:
        st.warning(f"Error fitting curve: {e}")
        return None, None

# --- Select Ticker ---
selected_ticker = st.selectbox("Select a ticker", sorted(df_bonds['TICKER'].unique()))
df_filtered = df_bonds[df_bonds['TICKER'] == selected_ticker]

if len(df_filtered) < 2:
    st.warning("Not enough bonds to fit a curve.")
else:
    x = df_filtered['DURADJMOD'].values
    y = df_filtered['OAS_BP'].values
    params, y_fit = fit_ns_curve(x, y)

    if params is not None:
        x_sorted_idx = np.argsort(x)
        x_sorted = x[x_sorted_idx]
        y_fit_sorted = y_fit[x_sorted_idx]
        y_fit_upper = y_fit_sorted * (1 + deviation_threshold / 100)
        y_fit_lower = y_fit_sorted * (1 - deviation_threshold / 100)

        # Assign colors
        colors = df_filtered['Own?'].map({'Y': 'red', 'N': 'blue'}).tolist()

        # Plot
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=df_filtered['DURADJMOD'], y=df_filtered['OAS_BP'],
                                 mode='markers', marker=dict(size=8, color=colors),
                                 name='Bonds', customdata=df_filtered[['ID']],
                                 hovertemplate="ID: %{customdata[0]}<br>Dur: %{x}<br>OAS: %{y}<extra></extra>"))
        fig.add_trace(go.Scatter(x=x_sorted, y=y_fit_sorted, mode='lines', name='NS Fit', line=dict(color='black')))
        fig.add_trace(go.Scatter(x=x_sorted, y=y_fit_upper, mode='lines', name='Upper Bound', line=dict(dash='dash')))
        fig.add_trace(go.Scatter(x=x_sorted, y=y_fit_lower, mode='lines', name='Lower Bound', line=dict(dash='dash')))

        fig.update_layout(title=f"{selected_ticker} Curve Fit",
                          xaxis_title="Duration (DURADJMOD)",
                          yaxis_title="OAS (bps)",
                          height=600)

        st.plotly_chart(fig, use_container_width=True)

        # --- Outliers ---
        df_filtered['NS_FIT'] = ns_func(df_filtered['DURADJMOD'], *params)
        df_filtered['Deviation'] = df_filtered['OAS_BP'] - df_filtered['NS_FIT']
        df_filtered['Above/Below'] = np.where(df_filtered['Deviation'] > 0, 'Above', 'Below')

        df_below_owned = df_filtered[
            (df_filtered['Own?'] == 'Y') &
            (df_filtered['Deviation'] < -deviation_threshold / 100 * df_filtered['NS_FIT'])
        ].copy()

        df_above_unowned = df_filtered[
            (df_filtered['Own?'] == 'N') &
            (df_filtered['Deviation'] > deviation_threshold / 100 * df_filtered['NS_FIT'])
        ].copy()

        # --- Trade Generation ---
        trade_signals = []
        for _, row_below in df_below_owned.iterrows():
            for _, row_above in df_above_unowned.iterrows():
                if row_above['DURADJMOD'] > row_below['DURADJMOD']:
                    ratio = (row_above['OAS_BP'] - row_below['OAS_BP']) / (row_above['DURADJMOD'] - row_below['DURADJMOD'])
                    if ratio > 10:
                        trade_signals.append({
                            "Owned ID": row_below['ID'],
                            "Matched ID": row_above['ID'],
                            "Ratio OAS/Dur": round(ratio, 2),
                            "OAS Diff": round(row_above['OAS_BP'] - row_below['OAS_BP'], 2),
                            "Dur Diff": round(row_above['DURADJMOD'] - row_below['DURADJMOD'], 2),
                            "Deviation Owned": round(row_below['Deviation'], 2),
                            "Deviation Matched": round(row_above['Deviation'], 2),
                            "Dev Diff": round(row_above['Deviation'] - row_below['Deviation'], 2)
                        })

        # --- Tables ---
        st.subheader("Outliers (Owned & Below Line)")
        st.dataframe(df_below_owned[['ID', 'CUSIP', 'Deviation']].reset_index(drop=True), use_container_width=True)

        st.subheader("Potential Trade Targets")
        if trade_signals:
            df_trades = pd.DataFrame(trade_signals)
            st.dataframe(df_trades, use_container_width=True)
        else:
            st.info("No qualifying trade signals found for this ticker.")
import io

# --- Optional Excel Export ---
if trade_signals:
    output_file = io.BytesIO()
    df_trades.to_excel(output_file, index=False, engine='xlsxwriter')
    output_file.seek(0)

    st.download_button(
        label="ðŸ“¥ Download Trade Signals as Excel",
        data=output_file,
        file_name=f"{selected_ticker}_trade_signals.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )
